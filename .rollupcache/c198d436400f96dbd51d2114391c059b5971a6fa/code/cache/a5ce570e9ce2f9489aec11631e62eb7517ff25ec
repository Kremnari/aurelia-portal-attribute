{"code":"import * as tslib_1 from \"tslib\";\r\nimport { customAttribute, templateController, ViewSlot, BoundViewFactory, bindable } from 'aurelia-templating';\r\nimport { PLATFORM } from 'aurelia-pal';\r\nconst document = PLATFORM.global.document;\r\nlet Portal = Portal_1 = class Portal {\r\n    constructor(viewFactory, originalViewslot) {\r\n        this.viewFactory = viewFactory;\r\n        this.originalViewslot = originalViewslot;\r\n        this.strict = false;\r\n        this.initialRender = false;\r\n        this.currentTarget = unset;\r\n    }\r\n    static getTarget(target, context) {\r\n        if (target) {\r\n            if (typeof target === 'string') {\r\n                let queryContext = document;\r\n                if (context) {\r\n                    if (typeof context === 'string') {\r\n                        context = document.querySelector(context);\r\n                    }\r\n                    if (context instanceof Element) {\r\n                        queryContext = context;\r\n                    }\r\n                }\r\n                target = queryContext.querySelector(target);\r\n            }\r\n            if (target instanceof Element) {\r\n                return target;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    bind(bindingContext, overrideContext) {\r\n        if (!this.callbackContext) {\r\n            this.callbackContext = bindingContext;\r\n        }\r\n        let view = this.view;\r\n        if (!view) {\r\n            view = this.view = this.viewFactory.create();\r\n        }\r\n        const shouldInitRender = this.initialRender;\r\n        if (shouldInitRender) {\r\n            this.originalViewslot.add(view);\r\n        }\r\n        view.bind(bindingContext, overrideContext);\r\n        if (shouldInitRender) {\r\n            this.originalViewslot.remove(view);\r\n        }\r\n    }\r\n    attached() {\r\n        this.isAttached = true;\r\n        return this.render();\r\n    }\r\n    detached() {\r\n        this.isAttached = false;\r\n        if (this.viewSlot) {\r\n            this.viewSlot.detached();\r\n        }\r\n    }\r\n    unbind() {\r\n        if (this.viewSlot) {\r\n            this.viewSlot.remove(this.view);\r\n            this.viewSlot = null;\r\n        }\r\n        this.view.unbind();\r\n        this.callbackContext = null;\r\n    }\r\n    getTarget() {\r\n        let target = Portal_1.getTarget(this.target, this.renderContext);\r\n        if (target === null) {\r\n            if (this.strict) {\r\n                throw new Error('Render target not found.');\r\n            }\r\n            else {\r\n                target = document.body;\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n    render() {\r\n        const oldTarget = this.currentTarget;\r\n        const view = this.view;\r\n        const target = this.currentTarget = this.getTarget();\r\n        const oldViewSlot = this.viewSlot;\r\n        if (oldTarget === target && oldViewSlot) {\r\n            return;\r\n        }\r\n        let addAction = () => {\r\n            if (this.isAttached) {\r\n                return Promise.resolve(typeof this.activating === 'function'\r\n                    ? this.activating.call(this.callbackContext, target, view)\r\n                    : null).then(() => {\r\n                    if (target === this.currentTarget || oldTarget === unset) {\r\n                        const viewSlot = this.viewSlot = new ViewSlot(target, true);\r\n                        viewSlot.attached();\r\n                        viewSlot.add(view);\r\n                        this.removed = false;\r\n                    }\r\n                    return Promise.resolve().then(() => {\r\n                        typeof this.activated === 'function'\r\n                            ? this.activated.call(this.callbackContext, target, view)\r\n                            : null;\r\n                    });\r\n                });\r\n            }\r\n            return Promise.resolve(null);\r\n        };\r\n        if (oldViewSlot) {\r\n            return Promise.resolve(typeof this.deactivating === 'function'\r\n                ? this.deactivating.call(this.callbackContext, oldTarget, view)\r\n                : null).then(() => {\r\n                if (typeof this.deactivated === 'function') {\r\n                    this.deactivated.call(this.callbackContext, oldTarget, view);\r\n                }\r\n                this.viewSlot = null;\r\n                if (!this.removed) {\r\n                    oldViewSlot.remove(view);\r\n                    this.removed = true;\r\n                }\r\n                return addAction();\r\n            });\r\n        }\r\n        return Promise.resolve(addAction());\r\n    }\r\n    targetChanged() {\r\n        return this.render();\r\n    }\r\n};\r\n/**\r\n * Only needs the BoundViewFactory as a custom viewslot will be used\r\n */\r\nPortal.inject = [BoundViewFactory, ViewSlot];\r\ntslib_1.__decorate([\r\n    bindable({\r\n        primaryProperty: true,\r\n        defaultValue: null\r\n    })\r\n], Portal.prototype, \"target\", void 0);\r\ntslib_1.__decorate([\r\n    bindable({ changeHandler: 'targetChanged' })\r\n], Portal.prototype, \"renderContext\", void 0);\r\ntslib_1.__decorate([\r\n    bindable()\r\n], Portal.prototype, \"strict\", void 0);\r\ntslib_1.__decorate([\r\n    bindable()\r\n], Portal.prototype, \"initialRender\", void 0);\r\ntslib_1.__decorate([\r\n    bindable()\r\n], Portal.prototype, \"deactivating\", void 0);\r\ntslib_1.__decorate([\r\n    bindable()\r\n], Portal.prototype, \"activating\", void 0);\r\ntslib_1.__decorate([\r\n    bindable()\r\n], Portal.prototype, \"activated\", void 0);\r\ntslib_1.__decorate([\r\n    bindable()\r\n], Portal.prototype, \"deactivated\", void 0);\r\ntslib_1.__decorate([\r\n    bindable()\r\n], Portal.prototype, \"callbackContext\", void 0);\r\nPortal = Portal_1 = tslib_1.__decorate([\r\n    templateController(),\r\n    customAttribute('portal')\r\n], Portal);\r\nexport { Portal };\r\nconst unset = {};\r\nvar Portal_1;\r\n","dts":{"name":"C:/git/aurelia-portal-attribute/dist/types/portal.d.ts","text":"import { OverrideContext } from 'aurelia-binding';\r\nimport { ViewSlot, BoundViewFactory, View } from 'aurelia-templating';\r\nexport declare type PortalLifecycleCallback = (target: Element, view: View) => Promise<any> | any;\r\nexport declare class Portal {\r\n    private viewFactory;\r\n    private originalViewslot;\r\n    private static getTarget(target, context?);\r\n    /**\r\n     * Only needs the BoundViewFactory as a custom viewslot will be used\r\n     */\r\n    static inject: (typeof BoundViewFactory | typeof ViewSlot)[];\r\n    /**\r\n     * Target to render to, CSS string | Element\r\n     */\r\n    target: string | Element | null | undefined;\r\n    renderContext: string | Element | null | undefined;\r\n    strict: boolean;\r\n    initialRender: boolean;\r\n    /**\r\n     * Will be called when the attribute receive new target after the first render.\r\n     */\r\n    deactivating: PortalLifecycleCallback;\r\n    /**\r\n     * Will be called after `portaled` element has been added to target\r\n     */\r\n    activating: PortalLifecycleCallback;\r\n    /**\r\n     * Will be called after activating has been resolved\r\n     */\r\n    activated: PortalLifecycleCallback;\r\n    /**\r\n     * Will be called after deactivating has been resolved.\r\n     */\r\n    deactivated: PortalLifecycleCallback;\r\n    /**\r\n     * The object that will becontextwhen calling life cycle methods above\r\n     */\r\n    callbackContext: any;\r\n    private currentTarget;\r\n    private isAttached;\r\n    private viewSlot;\r\n    private view;\r\n    private removed;\r\n    constructor(viewFactory: BoundViewFactory, originalViewslot: ViewSlot);\r\n    bind(bindingContext: any, overrideContext: OverrideContext): void;\r\n    attached(): Promise<void | null> | undefined;\r\n    detached(): void;\r\n    unbind(): void;\r\n    private getTarget();\r\n    private render();\r\n    targetChanged(): Promise<void | null> | undefined;\r\n}\r\n"}}
